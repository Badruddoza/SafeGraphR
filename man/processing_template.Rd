% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/volume_over_time.R
\name{processing_template}
\alias{processing_template}
\title{Perform basic processing and preparation of visits_by_day data}
\usage{
processing_template(
  dt,
  norm = NULL,
  by = NULL,
  date = "date",
  visits_by_day = "visits_by_day",
  origin = 0,
  filter = NULL,
  single_by = NULL,
  ma = 7,
  drop_ma = TRUE,
  first_date = NULL,
  silent = FALSE
)
}
\arguments{
\item{dt}{A \code{data.table} (or something that can be coerced to \code{data.table}).}

\item{norm}{A \code{data.table} containing columns for \code{date}, any number of the elements of \code{by}, and a final column containing a normalization factor. The \code{visits_by_day} values will be divided by that normalization factor after merging. \code{growth_over_time} will generate this internally for you, but you can make (a standard version of it) easily by just using \code{read_many_csvs(makedate = TRUE)} to load in all of the files in the \code{normalization_stats} or \code{normalization_stats_backfill} folders from AWS, limiting it to just the all-state rows, and then passing in just the \code{date} and \code{total_devices_seen} columns. If null, applies no normalization (if your analysis covers a reasonably long time span, you want normalization).}

\item{by}{A character vector of the variable names that indicate groups to calculate growth separately by.}

\item{date}{Character variable indicating the date variable.}

\item{visits_by_day}{Character variable indicating the variable containing the \code{visits_by_day} numbers.}

\item{origin}{The value indicating no growth/initial value. The first date for each group will have this value. Usually 0 (for "0 percent growth") or 1 ("100 percent of initial value").}

\item{filter}{A character variable describing a subset of the data to include, for example \code{filter = 'state_fips == 6'} to only include California.}

\item{single_by}{A character variable for the name of a new variable that combines all the different variables in \code{by} into one variable, handy for passing to \code{graph_template()}.}

\item{ma}{Number of days over which to take the moving average.}

\item{drop_ma}{Drop observations for which \code{adj_visits} is missing because of the moving-average adjustment.}

\item{first_date}{After implementing the moving-average, drop all values before this date and calculate growth starting from this date. If \code{NULL}, uses the first date that's not missing after the moving average.}

\item{silent}{Omit the warning and detailed report that occurs for values of \code{dt} that find no match in \code{norm}, as well as the one if you try not to normalize at all.}
}
\description{
This function takes data read in from SafeGraph patterns files that has had \code{expand_integer_json()} already applied to its \code{visits_by_day} variable (or used the \code{expand_int = 'visits_by_day'} option in \code{read_patterns()} or \code{read_many_patterns()}). It aggregates the data to the \code{date-by} level, normalizes according to the size of the sample, calculates a moving average, and also calculates growth since the \code{start_date} for each \code{by} category. The resulting \code{data.table}, with one row per \code{date} per combination of \code{by}, can be used for results and insight, or passed to \code{graph_template()} for a quick graph.
}
\details{
The result is the same \code{data.table} that was passed in, with some modifications: the data will be aggregated (using \code{sum}) to the \code{date-by} level, with \code{visits_by_day} as the only other surviving column. Three new columns are added: The normalization variable (from \code{norm}, or just a variable \code{norm} equal to 1 if \code{norm = NULL}), \code{adj_visits}, which is \code{visits_by_day} adjusted for sample size and with a moving average applied, and \code{growth} which tracks the percentage change relative to the earliest value of \code{adj_visits} that is not missing.
}
\examples{

# Generally you'd be doing this with data that comes from read_many_patterns()
# But here's an example using randomly generated data

dt <- data.table::data.table(date = rep(lubridate::ymd('2020-01-01') + lubridate::days(0:300),2),
state_fips = c(rep(6, 301), rep(7,301)),
visits_by_day = rpois(602, lambda = 10))

norm <- data.table::data.table(date = rep(lubridate::ymd('2020-01-01') + lubridate::days(0:300),2),
                               state_fips = c(rep(6, 301), rep(7,301)),
                               total_devices_seen = rpois(602, lambda = 10000))

processed_data <- processing_template(dt, norm = norm, by = 'state_fips')

}
